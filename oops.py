# -*- coding: utf-8 -*-
"""OOPS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1md9sJJ8AarKniU_H0t6q4WltkFMa33Yq
"""

#constructors in python:

###Initialization of objects: Constructors are used to initialize the objects of a class. Like __init__()
###They allow you to set default values for attributes or properties, and also allow you to initialize the object with custom data.

#disadvantage: Overloading not possible. Can't have multiple constructors.


#Decorators are a very powerful and useful tool in Python since it allows programmers to modify the behaviour of a function or class.

##Destructors are called when an object gets destroyed. In Python, destructors are not needed as much as in C++ because
##Python has a garbage collector that handles memory management automatically.
##The __del__() method is a known as a destructor method in Python.


class Student():
    def __init__(self,age,rank,nature):
        self.age = age
        #private
        self.__rank = rank
        self.__nature = nature

Stu1 = Student(20,10,"good")
#print(Stu1.nature)
#print(getattr(Stu1,"rank"))

class goodStudent(Student):
    def __init__(self,age,rank,nature,Topper):
        Student.age = age
        Student.__rank = rank
        Student.__nature = nature
        self.T = Topper
    def printstudent(self):
      print(Student.age, Student.__rank,Student.__nature,self.T)

Stu2 = goodStudent(19,1,"good",True)

Stu2.printstudent()
#print(getattr(Stu2,"T"))
Stu2.age

class Stud(Student):
  def __init__(self,age,rank,nature,Topper):
    super(Stud,self).__init__(age,rank,nature)
    self.Topper = Topper

obj1 = Stud(18,1,"good",True)
obj1.age

#multilevel inheritance

#parent class
class vehicle():
  def __init__(self,manufacturer,model,fuel):
    self.manufacturer = manufacturer
    self.model = model
    self.fuel = fuel

#child class
class car(vehicle):
  def __init__(self,manufacturer,model,fuel,air_condition,sunroof):
    super(car,self).__init__(manufacturer,model,fuel)

    self.air_condition = air_condition
    self.sunroof = sunroof

#child of child
class Electric(car):
  def __init__(self,manufacturer,model,fuel,air_condition,sunroof,distance):
    super(Electric,self).__init__(manufacturer,model,fuel,air_condition,sunroof)

    self.sunroof = sunroof

myobj = Electric("Tesla",2019,"petrol",True,False,150)
myobj.__dict__

myobj.air_condition

#abstract class
from abc import ABC, abstractmethod

class vehicle(ABC):

  @abstractmethod #to force the child class to maintain the decorum of parent class
  def get_value():
    pass

class car(vehicle):
  def __init__(self,make,model,fare):
    self.make = make
    self.model = model
    self.fare = fare

  #have to mention abstractmethod function
  def get_value(self):
    return self.fare * 100

myobj = car("tesla",2010,50000)
print(myobj.fare)
myobj.get_value()

x = ord('a')

y = chr(x)
y

#decorators

def div(a,b):
  return (a/b)

print(div(2,4))

#adding feature without touching the original func

def smart_div(func):

  def inner(a,b):
    if a < b:
      a,b = b,a
    return func(a,b)
  return inner

div = smart_div(div)
print(div(2,4))

